name: Extract CloudDrive Android Resources

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'CloudDrive version to extract (leave empty for latest)'
        required: false
        default: ''
  schedule:
    # Run every day at 00:00 UTC to check for new releases
    - cron: '0 0 * * *'

permissions:
  contents: write
  
jobs:
  extract-resources:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Install ILSpy CLI
      run: |
        dotnet tool install --global ilspycmd
        echo "ILSpy CLI installed successfully"
        ilspycmd --version

    - name: Get latest release info
      id: get-release
      run: |
        if [ -n "${{ github.event.inputs.version }}" ]; then
          VERSION="${{ github.event.inputs.version }}"
          echo "Using specified version: $VERSION"
        else
          # Get latest release version from GitHub API
          VERSION=$(curl -s https://api.github.com/repos/cloud-fs/cloud-fs.github.io/releases/latest | jq -r '.tag_name')
          echo "Latest version found: $VERSION"
        fi
        
        # Remove 'v' prefix if present
        VERSION_NUMBER=$(echo $VERSION | sed 's/^v//')
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
        echo "download_url=https://github.com/cloud-fs/cloud-fs.github.io/releases/download/$VERSION/clouddrive-2-android-x86_64-$VERSION_NUMBER.tgz" >> $GITHUB_OUTPUT

    - name: Download and extract CloudDrive release
      run: |
        echo "Downloading from: ${{ steps.get-release.outputs.download_url }}"
        
        # Create working directory
        mkdir -p work
        cd work
        
        # Download the release file
        curl -L -o clouddrive-android.tgz "${{ steps.get-release.outputs.download_url }}"
        
        # Extract the archive
        tar -xzf clouddrive-android.tgz
        
        # List contents to verify structure
        echo "Archive contents:"
        find . -name "*.dll" -type f | head -10
        
        # Find the actual directory structure
        EXTRACT_DIR=$(find . -name "CloudDriveModern.dll" -type f | head -1 | xargs dirname)
        echo "Found CloudDriveModern.dll in: $EXTRACT_DIR"
        
        # Create symbolic links for easier access
        if [ -n "$EXTRACT_DIR" ]; then
          ln -sf "$EXTRACT_DIR" framework
          echo "Created symlink: framework -> $EXTRACT_DIR"
        else
          echo "Error: CloudDriveModern.dll not found in archive"
          exit 1
        fi
        
        # Verify required files exist
        if [ ! -f "framework/CloudDriveModern.dll" ]; then
          echo "Error: CloudDriveModern.dll not found"
          exit 1
        fi
        
        if [ ! -f "framework/zh-CN/CloudDriveModern.resources.dll" ]; then
          echo "Error: CloudDriveModern.resources.dll not found"
          exit 1
        fi
        
        echo "Required DLL files found successfully"

    - name: Decompile DLL files
      run: |
        cd work
        
        # Create decompile directories
        mkdir -p decompile-en decompile-zh
        
        echo "Decompiling English resources..."
        ilspycmd -p -o ./decompile-en framework/CloudDriveModern.dll
        
        echo "Decompiling Chinese resources..."
        ilspycmd -p -o ./decompile-zh framework/zh-CN/CloudDriveModern.resources.dll
        
        # List decompiled files to debug
        echo "Decompiled English files:"
        find decompile-en -name "*.resx" || echo "No .resx files found in English decompile"
        
        echo "Decompiled Chinese files:"
        find decompile-zh -name "*.resx" || echo "No .resx files found in Chinese decompile"
        
        # Verify decompiled files exist
        if [ ! -f "decompile-en/CloudDriveModern.Resources.SharedResources.resx" ]; then
          echo "Error: English resources not found after decompilation"
          echo "Available files in decompile-en:"
          find decompile-en -type f | head -10
          exit 1
        fi
        
        if [ ! -f "decompile-zh/CloudDriveModern.Resources.SharedResources.zh-CN.resx" ]; then
          echo "Error: Chinese resources not found after decompilation"
          echo "Available files in decompile-zh:"
          find decompile-zh -type f | head -10
          exit 1
        fi
        
        echo "Decompilation completed successfully"

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Convert resources to Android XML
      run: |
        cd work
        
        # Create the conversion script with field completion functionality
        cat > convert_resources.py << 'EOF'
        import xml.etree.ElementTree as ET
        import os
        import zipfile
        import re
        import hashlib
        from pathlib import Path

        def sanitize_android_name(name):
            """Sanitize name for Android XML attribute (name attribute)"""
            # Replace common punctuation with descriptive words
            replacements = {
                '.': '_dot_',
                ',': '_comma_',
                '!': '_exclamation_',
                '?': '_question_',
                ':': '_colon_',
                ';': '_semicolon_',
                '(': '_lparen_',
                ')': '_rparen_',
                '[': '_lbracket_',
                ']': '_rbracket_',
                '{': '_lbrace_',
                '}': '_rbrace_',
                '/': '_slash_',
                '\\': '_backslash_',
                '@': '_at_',
                '#': '_hash_',
                '$': '_dollar_',
                '%': '_percent_',
                '&': '_and_',
                '*': '_asterisk_',
                '+': '_plus_',
                '-': '_minus_',
                '=': '_equals_',
                '<': '_lt_',
                '>': '_gt_',
                '|': '_pipe_',
                '~': '_tilde_',
                '^': '_caret_',
                '`': '_backtick_',
                "'": '_apostrophe_',
                '"': '_quote_'
            }
            
            # Replace punctuation with descriptive words
            sanitized = name
            for char, replacement in replacements.items():
                sanitized = sanitized.replace(char, replacement)
            
            # Replace spaces with underscores
            sanitized = sanitized.replace(' ', '_')
            
            # Replace any remaining non-alphanumeric characters with underscores
            sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', sanitized)
            
            # Remove consecutive underscores and leading/trailing underscores
            sanitized = re.sub(r'_+', '_', sanitized).strip('_')
            
            return sanitized

        def escape_android_value(value):
            """Escape special characters for Android XML string values"""
            # Escape XML special characters
            escaped = value.replace('&', '&amp;')
            escaped = escaped.replace('<', '&lt;')
            escaped = escaped.replace('>', '&gt;')
            escaped = escaped.replace('"', '\\"')
            escaped = escaped.replace("'", "\\'")
            # Preserve formatting placeholders like {0}, {1}, etc.
            return escaped

        def parse_resx_file(resx_file):
            """Parse .resx file and return a dictionary of name-value pairs"""
            try:
                tree = ET.parse(resx_file)
                root = tree.getroot()
                
                data_dict = {}
                for data in root.findall('.//data[@name]'):
                    name_attr = data.get('name')
                    value_elem = data.find('value')
                    
                    if name_attr and value_elem is not None and value_elem.text:
                        data_dict[name_attr] = value_elem.text.strip()
                
                return data_dict
                
            except Exception as e:
                print(f"Error parsing {resx_file}: {e}")
                return {}

        def create_android_xml(data_dict, output_file, prefix="cd2_locale_"):
            """Create Android strings.xml from data dictionary"""
            try:
                resources = ET.Element("resources")
                
                for name, value in data_dict.items():
                    string_elem = ET.SubElement(resources, "string")
                    android_name = f"{prefix}{name}"
                    string_elem.set("name", android_name)
                    # Escape special characters in the value
                    escaped_value = escape_android_value(value)
                    string_elem.text = escaped_value
                
                # Write to file with proper XML formatting
                tree_out = ET.ElementTree(resources)
                ET.indent(tree_out, space="  ", level=0)
                tree_out.write(output_file, encoding='utf-8', xml_declaration=True)
                
                print(f"Created Android XML: {output_file}")
                return True
                
            except Exception as e:
                print(f"Error creating Android XML {output_file}: {e}")
                return False

        def complete_missing_fields(en_data, zh_data):
            """Ensure both language dictionaries have the same keys"""
            all_keys = set(en_data.keys()) | set(zh_data.keys())
            
            # Create copies to avoid modifying original data
            en_completed = en_data.copy()
            zh_completed = zh_data.copy()
            
            # Fill missing fields in English with field names
            missing_in_en = []
            for key in all_keys:
                if key not in en_completed:
                    en_completed[key] = key
                    missing_in_en.append(key)
            
            # Fill missing fields in Chinese with field names
            missing_in_zh = []
            for key in all_keys:
                if key not in zh_completed:
                    zh_completed[key] = key
                    missing_in_zh.append(key)
            
            return en_completed, zh_completed, len(all_keys), missing_in_en, missing_in_zh

        def main():
            # File paths
            en_resx = "decompile-en/CloudDriveModern.Resources.SharedResources.resx"
            zh_resx = "decompile-zh/CloudDriveModern.Resources.SharedResources.zh-CN.resx"
            
            # Parse both resource files
            en_data = parse_resx_file(en_resx)
            zh_data = parse_resx_file(zh_resx)
            
            print(f"English original keys: {len(en_data)}")
            print(f"Chinese original keys: {len(zh_data)}")
            
            # Create sanitized versions of the data
            en_sanitized = {}
            zh_sanitized = {}
            
            for key, value in en_data.items():
                sanitized_key = sanitize_android_name(key)
                en_sanitized[sanitized_key] = value
            
            for key, value in zh_data.items():
                sanitized_key = sanitize_android_name(key)
                zh_sanitized[sanitized_key] = value
            
            # Complete missing fields
            en_completed, zh_completed, total_keys, missing_in_en, missing_in_zh = complete_missing_fields(
                en_sanitized, zh_sanitized
            )
            
            # Create output directories
            os.makedirs("android-resources/values", exist_ok=True)
            os.makedirs("android-resources/values-zh", exist_ok=True)
            
            # Create Android XML files
            success_en = create_android_xml(
                en_completed, 
                "android-resources/values/cd2.xml"
            )
            
            success_zh = create_android_xml(
                zh_completed, 
                "android-resources/values-zh/cd2.xml"
            )
            
            if not success_en or not success_zh:
                exit(1)
            
            # Create ZIP file
            with zipfile.ZipFile("clouddrive-android-resources.zip", 'w') as zip_file:
                zip_file.write("android-resources/values/cd2.xml", "values/cd2.xml")
                zip_file.write("android-resources/values-zh/cd2.xml", "values-zh/cd2.xml")
            
            print("Created clouddrive-android-resources.zip successfully")
            
            # Print detailed statistics
            print(f"\n=== ÁªüËÆ°‰ø°ÊÅØ ===")
            print(f"ÊÄªÂ≠óÁ¨¶‰∏≤Êï∞: {total_keys} ‰∏™")
            print(f"Ëã±ÊñáÂéüÊúâ: {len(en_data)} ‰∏™ÔºåË°•ÈΩê: {len(missing_in_en)} ‰∏™")
            print(f"‰∏≠ÊñáÂéüÊúâ: {len(zh_data)} ‰∏™ÔºåË°•ÈΩê: {len(missing_in_zh)} ‰∏™")
            
            # Output final stats for GitHub Actions to capture
            print(f"FINAL_STATS:TOTAL_KEYS:{total_keys}")
            print(f"FINAL_STATS:EN_ORIGINAL:{len(en_data)}")
            print(f"FINAL_STATS:ZH_ORIGINAL:{len(zh_data)}")
            print(f"FINAL_STATS:MISSING_EN:{len(missing_in_en)}")
            print(f"FINAL_STATS:MISSING_ZH:{len(missing_in_zh)}")

        if __name__ == "__main__":
            main()
        EOF
        
        # Run the conversion script
        python convert_resources.py

    - name: Verify generated files
      run: |
        cd work
        
        # Check if files were generated
        if [ ! -f "clouddrive-android-resources.zip" ]; then
          echo "Error: ZIP file not created"
          exit 1
        fi
        
        # Extract and verify ZIP contents
        unzip -l clouddrive-android-resources.zip
        
        # Show sample content from generated files
        echo "=== Sample English XML content ==="
        head -20 android-resources/values/cd2.xml
        
        echo "=== Sample Chinese XML content ==="
        head -20 android-resources/values-zh/cd2.xml
        
        # Verify both files have the same number of string elements
        echo "=== Verification: Checking string counts ==="
        en_count=$(grep -c '<string name=' android-resources/values/cd2.xml)
        zh_count=$(grep -c '<string name=' android-resources/values-zh/cd2.xml)
        
        echo "English strings count: $en_count"
        echo "Chinese strings count: $zh_count"
        
        if [ "$en_count" -eq "$zh_count" ]; then
          echo "‚úì SUCCESS: Both language files have the same number of strings"
        else
          echo "‚úó ERROR: String counts don't match: English=$en_count, Chinese=$zh_count"
          exit 1
        fi

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: clouddrive-android-resources-${{ steps.get-release.outputs.version_number }}
        path: work/clouddrive-android-resources.zip
        retention-days: 30

    - name: Create Release (if new version)
      if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        cd work
        
        # Extract statistics from the conversion output
        STATS_FILE="conversion_stats.txt"
        
        # Run conversion again to capture statistics
        python convert_resources.py > $STATS_FILE 2>&1
        
        # Extract key statistics using the FINAL_STATS format
        TOTAL_KEYS=$(grep "FINAL_STATS:TOTAL_KEYS:" $STATS_FILE | cut -d':' -f3 | tr -d ' ')
        EN_ORIGINAL=$(grep "FINAL_STATS:EN_ORIGINAL:" $STATS_FILE | cut -d':' -f3 | tr -d ' ')
        ZH_ORIGINAL=$(grep "FINAL_STATS:ZH_ORIGINAL:" $STATS_FILE | cut -d':' -f3 | tr -d ' ')
        MISSING_EN=$(grep "FINAL_STATS:MISSING_EN:" $STATS_FILE | cut -d':' -f3 | tr -d ' ')
        MISSING_ZH=$(grep "FINAL_STATS:MISSING_ZH:" $STATS_FILE | cut -d':' -f3 | tr -d ' ')
        
        # Set default values if extraction failed
        TOTAL_KEYS=${TOTAL_KEYS:-"N/A"}
        EN_ORIGINAL=${EN_ORIGINAL:-"N/A"}
        ZH_ORIGINAL=${ZH_ORIGINAL:-"N/A"}
        MISSING_EN=${MISSING_EN:-"0"}
        MISSING_ZH=${MISSING_ZH:-"0"}
        
        # Create simplified release notes with statistics
        cat > release_notes.md << EOF
        # CloudDrive Android ËµÑÊ∫êÊñá‰ª∂ v${{ steps.get-release.outputs.version_number }}
        
        ‰ªé CloudDrive ${{ steps.get-release.outputs.version }} Ëá™Âä®ÁîüÊàêÁöÑ Android XML ËµÑÊ∫êÊñá‰ª∂
        
        ## üìä ÁªüËÆ°‰ø°ÊÅØ
        - **ÊÄªÂ≠óÁ¨¶‰∏≤Êï∞**: $TOTAL_KEYS ‰∏™
        - **Ëã±ÊñáÂéüÊúâ**: $EN_ORIGINAL ‰∏™Ôºå**Ë°•ÈΩê**: $MISSING_EN ‰∏™
        - **‰∏≠ÊñáÂéüÊúâ**: $ZH_ORIGINAL ‰∏™Ôºå**Ë°•ÈΩê**: $MISSING_ZH ‰∏™
        
        > ‰∏§‰∏™ËØ≠Ë®ÄÊñá‰ª∂ÂåÖÂê´ÂÆåÂÖ®Áõ∏ÂêåÁöÑÂ≠óÁ¨¶‰∏≤ÈîÆ„ÄÇÁº∫Â§±ÁöÑÁøªËØëÂ∑≤Ëá™Âä®Áî®ÈîÆÂêçÂ°´ÂÖÖ„ÄÇ
        EOF
        
        # Check if this version already has a release
        RELEASE_TAG="android-resources-${{ steps.get-release.outputs.version_number }}"
        
        if gh release view $RELEASE_TAG >/dev/null 2>&1; then
          echo "Release $RELEASE_TAG already exists, updating assets and notes..."
          gh release edit $RELEASE_TAG \
            --notes-file release_notes.md
          gh release upload $RELEASE_TAG clouddrive-android-resources.zip --clobber
        else
          echo "Creating new release $RELEASE_TAG..."
          gh release create $RELEASE_TAG \
            --title "CloudDrive Android Resources ${{ steps.get-release.outputs.version_number }}" \
            --notes-file release_notes.md \
            clouddrive-android-resources.zip
        fi
        
        echo "Release notes:"
        cat release_notes.md
